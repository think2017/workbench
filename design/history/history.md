
## 用户中心浏览历史设计文档


### Cache类型(Redis)
  * 1# 保存客户端访问页面id的cache
     * 数据类型：有序集合(Sorted Sets)
     * 基于userid存储的key规则：HU_1101:112312156，5~8位(1101)是页面类型ID，第10位至结尾是用户ID。
     * 基于guid存储的key规则：HG_1101:53881806-548E-3141-9D8E-657DE849AE76，5~8位(1101)是页面类型ID，第10位至结尾是GUID。
     * 过期时间：基于userid存储的是60天，基于guid存储的是30天。

  * 2# 保存同一IP某一时间段提交的GUID。
     * 数据类型：列表(Lists)
     * KEY：HIP:192.168.190.126
     * 过期时间：当天有效



### 后台常驻型JOB
  * 描述：监听消息队列，将队列里面的数据拿出来，更新缓存。

  * 逻辑：
    * 首先判断队列里面的数据是否合法。
    
    * 获取CacheKey (Example：HU_101:112312156)
    * 如果有userid不为空，则根据userid build出缓存key，否则根据guid build出缓存key。


    * 防刷新检测
      * 目的：防止同一客户端恶意刷新同一页面，接口请求频繁，造成Redis频繁更新的问题。
      * 尝试读取1#缓存，读不到则视为该客户端的初次请求，检测通过。
      * 如果缓存存在，取集合第一个元素，value即为房源id，和当前房源id对比是否相同，如果相同则视为重复请求，检测不通过，直接return；
      * 如果不相同，检测通过。

    * 伪造GUID检测
      * 目的：防止恶意用户伪造大量GUID，刷爆我们的Redis。
      * 条件：取到的是GUID要做此检测，如果读到userid，不做此检测。
      * 根据ip取出2#缓存，将当前GUID Push到缓存里，去重，然后统计总数，如果超过一个限定值(比如1000)，则视为伪造GUID，检测不通过，直接return；
      * 没有超过限定值，检测通过。


    * 根据 页面类型ID 获取缓存的上限值max：
      * 新房(1101，1102)：    100条
      * 二手房(1201，1202)：  1000条
      * 租房(1301，1302)：    200条
      * 写字楼(1401，1402)：  50条
      * 商铺(1501，1502)：    50条
        
      * 执行以下命令，将房源id(1234567)作为集合的一个新成员，将访问时间(1395738645)作为该成员的分数，添加之集合里。
        * ZADD HU_101:112312156 1395738645 1234567

      * 通过以下命令，判断集合成员总数是否超出最大值，
        * ZCARD HU_101:112312156

      * 如果超过最大值，则要根据成员分数，末位淘汰。
        * ZREVRANGE HU_101:112312156 0 1
        * ZREM HU_101:112312156 1234567

      * 更新缓存的过期时间，将数据从Queue里面删掉。



### 用户登录同步浏览历史
    * 描述：某一个客户端发生登录动作，则将该客户端的GUID缓存数据同步到UserID缓存
    * 逻辑：
      * 根据GUID取出缓存数据，遍历该数据集合，
      * 将每一个成员add到基于userid存储的缓存中。
      * 完成后，将基于GUID的缓存集合删掉，并且更新基于userid的缓存的过期时间。


### 用户中心浏览历史URL

  * 新房   http://user.xxx.com/history/xinfang/
  * 二手房 http://user.xxx.com/history/fangyuan/
  * 好租   http://user.xxx.com/history/zu/
  * 写字楼 http://user.xxx.com/history/xzl/
  * 商铺   http://user.xxx.com/history/sp/


            
